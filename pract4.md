# Практическое занятие №4

П.Н. Советов, РТУ МИРЭА

В следующих задачах используется материал главы 6 учебника [The AWK Programming Language](https://cdn.hackaday.io/files/255831094543072/The_AWK_Programming_Language.pdf).

Необходимо реализовать ассемблер и интерпретатор кода для одноадресной виртуальной машины из раздела 6.1 An Assembler and Interpreter.

## Задача 1

Реализуйте первый проход ассемблера с получением промежуточного представления в символической форме.

Пример исходного текста (подсчет суммы вводимых чисел):

```
# print sum of input numbers (terminated by zero)
    ld zero # initialize sum to zero
    st sum
loop get # read a number
    jz done # no more input if number is zero
    add sum # add in accumulated sum
    st sum # store new value back in sum
    j loop # go back and read another number
done ld sum # print sum
    put
    halt
zero const 0
sum const
```

Таблица символов:

```
{'loop': 2, 'done': 7, 'zero': 10, 'sum': 11}
```

Промежуточный код:

```
('ld', 'zero')
('st', 'sum')
('get', 0)
('jz', 'done')
('add', 'sum')
('st', 'sum')
('j', 'loop')
('ld', 'sum')
('put', 0)
('halt', 0)
('const', 0)
('const', 0)
```

## Задача 2

Реализуйте второй проход ассемблера с заменой меток их значениями из таблицы символов.

```
0: ('ld', 10)
1: ('st', 11)
2: ('get', 0)
3: ('jz', 7)
4: ('add', 11)
5: ('st', 11)
6: ('j', 2)
7: ('ld', 11)
8: ('put', 0)
9: ('halt', 0)
10: ('const', 0)
11: ('const', 0)
```

## Задача 3

Закодируйте промежуточное представление в виде списка чисел в формате: первые 2 десятичные цифры задают код операции, а остальные 3 цифры – поле аргумента.

Коды операций:

```
{'const': 0, 'get': 1, 'put': 2, 'ld': 3, 'st': 4, 'add': 5, 'sub': 6, 'jpos': 7, 'jz': 8, 'j': 9, 'halt': 10}
```

Результат кодирования:

```
[3010, 4011, 1000, 8007, 5011, 4011, 9002, 3011, 2000, 10000, 0, 0]
```

## Задача 4

Реализуйте интерпретацию кода, полученного в предыдущей задаче.

Пример сеанса работы с интерпретатором:

```
<- 1
<- 2
<- 3
<- 4
<- 5
<- 6
<- 7
<- 8
<- 9
<- 0
-> 45
```

## Задача 5

Ниже представлен набросок наивной реализации виртуальной стековой машины.

```Python
stack = [0] * 16
sp = 0

def push(x):
    global sp
    stack[sp] = x
    sp += 1

def pop():
    global sp
    sp -= 1
    return stack[sp]

def add():
    return push(pop() + pop())

def execute(code):
    for op, *args in code:
        op(*args)

stack_code = [
    (push, 1),
    (push, 2),
    (add,)
]

execute(stack_code)
```

Реализуйте дополнительные арифметические операции для вычисления дискриминанта. Потребуется также команда вывода результата на экран.

## Задача 6

Добавьте недостающие операции, чтобы заработал пример из задачи 1.

## Задача 7

Ниже представлен набросок наивной реализации виртуальной регистровой машины.

```Python
regs = [0] * 16

def move(r, x):
    regs[r] = x

def add(rd, rs1, rs2):
    regs[rd] = regs[rs1] + regs[rs2]

def execute(code):
    for op, *args in code:
        op(*args)

reg_code = [
    (move, 0, 1),
    (move, 1, 2),
    (add, 2, 0, 1)
]

execute(reg_code)
```

Реализуйте дополнительные арифметические операции для вычисления дискриминанта. Потребуется также команда вывода результата на экран.

## Задача 8

Добавьте недостающие операции, чтобы заработал пример из задачи 1.

## Задача 9

Для работы с Wasm можно воспользоваться [онлайн-компилятором](https://wasdk.github.io/WasmFiddle/).

Реализуйте на Си формулу:

$$
S = \frac{n(n + 1)}{2}
$$

Транслируйте код в Wasm и проверьте, что работает вызов:

```JavaScript
console.log(wasmInstance.exports.S(10));
```

## Задача 10

Реализуйте на Wasm и встройте в html-страницу пример из задачи 1. Вам понадобится использовать в качестве импортированных функций prompt и alert.


